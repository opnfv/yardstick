{
  "comments": [
    {
      "key": {
        "uuid": "9a3d3df0_e530d2ea",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-09T21:59:36Z",
      "side": 1,
      "message": "probe_dpdk won\u0027t work if PCI is missing.\n\nWe only want to try DPDK probe if \u0027drivers\u0027 is the only missing field.\n\nso it should be  {\"driver\"} \u003d\u003d missing_fields_set\nor whatever set equivalence.\n\n\nthis is only a baremetal and standalone workaround when a device is already bound and we haven\u0027t hardcoded the kernel driver.\n\nI haven\u0027t reproduced this issue, and I don\u0027t know we wouldn\u0027t hardcode the driver if we already know the PCI BUS and MAC.",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_25a0faf3",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-09T22:59:34Z",
      "side": 1,
      "message": "no, I guess this should be\n\n            if \"driver\" in missing_fields_set and \"vpci\" not in missing_fields_set:\n\nif we have PCI and not driver.  But this case should never really happen.",
      "parentUuid": "9a3d3df0_e530d2ea",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_e58c5282",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 6831
      },
      "writtenOn": "2017-10-09T23:44:51Z",
      "side": 1,
      "message": "as you like, i made it like this based on the revision 13.",
      "parentUuid": "9a3d3df0_25a0faf3",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_85f3c609",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 6831
      },
      "writtenOn": "2017-10-09T23:53:59Z",
      "side": 1,
      "message": "ok, i see the difference, but i don\u0027t understand how if interface A doesn\u0027t have a driver but interface B only has a driver, then probe_dpdk_drivers will work.\n\nthis whole \"check by interface and then act by node\" modus operandi seems dangerous/high degree of difficulty.",
      "parentUuid": "9a3d3df0_e58c5282",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_e5e3b231",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-10T00:12:49Z",
      "side": 1,
      "message": "why node based? originally it was to save ssh connections with SshManager, maybe.\n\nalso that fact that for Ixia we can\u0027t ssh, it will error, so we need to make sure we only ssh when we have to.  \n\nif we do a loop over all the interfaces, and ssh once the first interface that needs probing is found, raising exceptions on SSH error, then it should work.\n\nbut then we want to cache the ssh connection when we loop each interface.\n\nif we have the ssh connection cached, then we could check each interface and only unbind one interface.\n\nprobe_netdevs and dpdk status dump, will dump info for all devices, but dict.update() should make sure things aren\u0027t clobbered.\n\n\nfor some reason I though dpdk rebind was global, but we can rebind each interface individually.\n\nmaybe.",
      "parentUuid": "9a3d3df0_85f3c609",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_25d59a43",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-10T00:14:01Z",
      "side": 1,
      "message": "also if any interface still has missing keys, then we have to raise exception and fail the whole test as well.",
      "parentUuid": "9a3d3df0_e5e3b231",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a3d3df0_3a3f5e27",
        "filename": "yardstick/network_services/helpers/dpdkbindnic_helper.py",
        "patchSetId": 15
      },
      "lineNbr": 169,
      "author": {
        "id": 6831
      },
      "writtenOn": "2017-10-17T16:50:31Z",
      "side": 1,
      "message": "no, it was completely node first, then interface per node.  sure SshManager was the attempt to reuse connections, but that was too meager a reason and instead i made the DpdkNode class which could hold on to an SSH connection for itself and do much more.\n\nnow it is check interfaces, then issue commands that show no indication of affecting individual interfaces.  see how line 165 aggregates the missing fields from all the interfaces but an earlier patch set wanted to know if any interface knew everything about itself other than its driver.  strictly speaking these are not the same test.\n\n any({\u0027driver\u0027} \u003d\u003d intf.missing_fields for intf in self.dpdk_interfaces.values())\n\nvs\n\n \u0027driver\u0027 in set(chain.from_iterable(self.interface_missing_iter))\n\nif an interface is missing both \u0027driver\u0027 and something else, the first won\u0027t match and the second will.\n\nthen which of lines 170, 176, 177, 178, 188-190 affect a single interface?  i don\u0027t see any targeting of the interface.  if it works, then fine, but it isn\u0027t making 100% sense to me.",
      "parentUuid": "9a3d3df0_25d59a43",
      "revId": "39a0db310e6ac8c0324a3c55f28ffae03b53a072",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    }
  ]
}