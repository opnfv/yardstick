{
  "comments": [
    {
      "key": {
        "uuid": "da33351e_4e892074",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 346,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-04T05:43:13Z",
      "side": 1,
      "message": "run lspci -k here, and then try probe_netdevs?\n\nhow do we get PCI address/",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_6e84e45d",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 366,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-04T05:43:13Z",
      "side": 1,
      "message": "we get vpci from here.",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_ce3890d5",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 394,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-04T05:00:58Z",
      "side": 1,
      "message": "why did you change this?",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_4ea2c0fd",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 394,
      "author": {
        "id": 6507
      },
      "writtenOn": "2017-10-04T05:23:51Z",
      "side": 1,
      "message": "changed based on the comments",
      "parentUuid": "da33351e_ce3890d5",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_2983f5cc",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 394,
      "author": {
        "id": 6831
      },
      "writtenOn": "2017-10-04T18:36:37Z",
      "side": 1,
      "message": "why are we making an entirely new list of entirely new dictionaries, if they have a \u0027pkey\u0027 key?\n\nthe one place that uses this method passes in its copy of the list and discards that value for the result of this method, so this method may as well update in place without all the duplication.  while i was wrong that this method \"doesn\u0027t mutate\", it doesn\u0027t *need* to mutate, that is something it\u0027s users could need, but the one current user *doesn\u0027t* need it.\n\nif we think this duplicating will be used somewhere else, then i would want its name changed to something that reflects the fact that it is making a \"nearly\" separate data structure for these strings.  Nearly because any node that doesn\u0027t have a \u0027pkey\u0027 value will appear in both lists.\n\n(if this we done as an interpolation, then no mutating would be needed, but the try-except blocks are hard to do within interpolations.)\n\n @staticmethod\n def make_node_with_string_pkey(node):\n   try:\n     return dict(node, pkey\u003dssh.convert_key_to_str(node[\u0027pkey\u0027]))\n   except KeyError:\n     return node\n\n @classmethod\n def make_nodes_with_string_pkeys(cls, nodes):\n  return [cls._make_node_with_string_pkey(node) for node in nodes]\n\n @staticmethod\n def convert_pkeys_to_string(nodes):\n   for node in nodes:\n     try:\n       node[\u0027pkey\u0027] \u003d ssh.convert_key_to_str(node[\u0027pkey\u0027])\n     except KeyError:\n       pass\n   # intentionally return None, as {}.update and [].extend do\n\n* no mutating\n* no enumeration\n* make_nodes_with_string_pkeys is identical behavior, though i fail to see why new copies of the nodes are necessary\n* convert_pkeys_to_string is sufficient for the current user\u0027s need\n* more descriptive method name\n* non-protected method names",
      "parentUuid": "da33351e_4ea2c0fd",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_2e32dcf1",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 405,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-04T05:00:58Z",
      "side": 1,
      "message": "we don\u0027t want to make another ssh connection,\n\nthis needs to be moved into the probe_netdevs logic.",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_6e9d04bc",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 405,
      "author": {
        "id": 6507
      },
      "writtenOn": "2017-10-04T05:23:51Z",
      "side": 1,
      "message": "probe_netdevs will not work if nic is already bind to dpdk or vifio",
      "parentUuid": "da33351e_2e32dcf1",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_ae7a6c74",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 405,
      "author": {
        "id": 1402
      },
      "writtenOn": "2017-10-04T05:43:13Z",
      "side": 1,
      "message": "yes, I\u0027m saying move this logic into the function before probe netdevs.\n\nwait, how do we get the PCI address if the device is unbound?\n\nwe get vpci from probe_netdevs.",
      "parentUuid": "da33351e_6e9d04bc",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_ae56eccb",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 405,
      "author": {
        "id": 6507
      },
      "writtenOn": "2017-10-04T06:00:58Z",
      "side": 1,
      "message": "vpci, for BM \u0026 SV is already known :) and we populate in nodes before we execute this function",
      "parentUuid": "da33351e_ae7a6c74",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_ae0d4cea",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 405,
      "author": {
        "id": 6507
      },
      "writtenOn": "2017-10-04T06:05:11Z",
      "side": 1,
      "message": "I would like to keep it this way because, we execute this only if driver is not populated other wise this function will be ignored.",
      "parentUuid": "da33351e_ae56eccb",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da33351e_496bd91d",
        "filename": "yardstick/benchmark/scenarios/networking/vnf_generic.py",
        "patchSetId": 11
      },
      "lineNbr": 405,
      "author": {
        "id": 6831
      },
      "writtenOn": "2017-10-04T18:36:37Z",
      "side": 1,
      "message": "i agree about the SshManager, it is useless and needs to be removed.  i don\u0027t feel strongly about when it happens.",
      "parentUuid": "da33351e_ae0d4cea",
      "revId": "7737f609a83a648649d2804cac8d80fb627f0eda",
      "serverId": "bbac25d2-bf60-4904-9ba8-a72fc000d6c5",
      "unresolved": false
    }
  ]
}